angular.module('wellFollowed', ['ui.router', 'ngMessages', 'wfTemplates', 'wfLibTemplates', 'ui.calendar', 'LocalStorageModule', 'ui.bootstrap.modal', 'ui.bootstrap.alert', 'angular-loading-bar']).config(["$stateProvider", "$urlRouterProvider", "$httpProvider", "cfpLoadingBarProvider", function($stateProvider, $urlRouterProvider, $httpProvider, cfpLoadingBarProvider) {

    var formatDate = function(data) {
        if (!!data) {
            for (var key in data) {
                if (data[key] instanceof Date)
                    data[key] = moment(data[key]);

                if (!!data[key].format)
                    data[key] = data[key].format('YYYY-MM-DD[T]HH:mm:ssZZ');
                else if (typeof data[key] === 'object')
                    formatDate(data[key]);
            }
        }
        return data;
    };

    $httpProvider.defaults.transformRequest.unshift(formatDate);

    $httpProvider.interceptors.push('$wfAuthInterceptor');

    $httpProvider.interceptors.push(["$q", "$rootScope", function($q, $rootScope) {
        var errorHandler = function(rejection) {
            $rootScope.$broadcast('wfError', rejection.message);

            return $q.reject(rejection);
        };

        return {
            'requestError': errorHandler,
            'responseError': errorHandler
        };
    }]);

    // Enregistrement des routes de l'application.
    // Si un attribut "name" est renseigné, l'élément sera ajouté automatiquement au menu.
    // L'attribut "template" contiendra toujours une directive englobant l'ensemble d'une page.
    $stateProvider
        .state('login', {
            url: '/connexion',
            template: '<wf-login></wf-login>'
        })
        .state('sensor', {
            url: '/',
            template: '<wf-sensor></wf-sensor>'
        })
        .state('calendar', {
            url: '/calendrier',
            template: '<wf-planning></wf-planning>'
        })
        .state('account', {
            url: '/compte',
            template: '<wf-account></wf-account>'
        })
        .state('subscription', {
            url: '/compte/inscription',
            template: '<wf-account-create></wf-account-create>'
        })
        .state('rtSimulation', {
            url: '/dummy/rtSimulation/:sensorName',
            template: function(params) { return '<wf-dummy-rt-simulation sensor-name="' + params.sensorName + '"></wf-dummy-rt-simulation>'; }
        })
        .state('admin', {
            url: '/admin',
            abstract: true,
            template: '<wf-admin></wf-admin>'
        })
        .state('admin.institutionTypes', {
            url: '/institution-types',
            template: '<wf-admin-institution-types></wf-admin-institution-types>'
        })
        .state('admin.institutionType', {
            url: '/institution-type/:id',
            template: function(params) { return '<wf-admin-institution-type institution-type-id="' + params.id + '"></wf-admin-institution-type>'; }
        })
        .state('admin.institutions', {
            url: '/institutions',
            template: '<wf-admin-institutions></wf-admin-institutions>'
        })
        .state('admin.institution', {
            url: '/institution/:id',
            template: function(params) { return '<wf-admin-institution institution-id="' + params.id + '"></wf-admin-institution>'; }
        });

    $urlRouterProvider.otherwise('/');

    cfpLoadingBarProvider.includeSpinner = false;
}])
.run(["$wfAuth", "$rootScope", "wfCrudTypes", function($wfAuth, $rootScope, wfCrudTypes) {
    $rootScope.wfCrudTypes = wfCrudTypes;
    $wfAuth.fillAuthData();
}]);
angular.module('wellFollowed').directive('wfAccountCreate', function($wfAuth) {
   return {
       restrict: 'E',
       templateUrl: 'account/wf-account-create.html',
       require: '^wfApp',
       link: function(scope, element, attributes, wfApp) {

           wfApp.showErrors(false);

           scope.user = {};

           scope.subscribe = function() {
               $wfAuth.createUser(scope.user).then(function(result) {

               });
           };
       }
   };
});
angular.module('wellFollowed').directive('wfAccount', function() {
   return {
       restrict: 'E',
       templateUrl: 'account/wf-account.html'
   }
});
angular.module('wellFollowed').directive('wfLogin', function($wfAuth, $location) {
    return {
        restrict: 'E',
        templateUrl: 'account/wf-login.html',
        require: '^wfApp',
        link: function (scope, element, attributes, wfApp) {

            wfApp.showErrors(false);

            scope.login = function() {
                $wfAuth.login({
                    username: scope.username,
                    password: scope.password
                }).then(function (result) {
                    $location.path("/calendrier");
                });
            }

        }
    };
});
angular.module('wellFollowed').directive('wfAlerts', function(wfAlertTypes, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'common/wf-alerts.html',
        scope: {
            alerts: '=?'
        },
        link: function(scope, element, attributes) {
            scope.alerts = scope.alerts || [];

            scope.alertTypes = wfAlertTypes;

            scope.$on('wfError', function(message) {
                scope.alerts.push({
                    type: wfAlertTypes.error,
                    message: message
                });
            });

            scope.close = function(alert) {
                scope.alerts.splice(scope.alerts.indexOf(alert), 1);
            };

            scope.$watch('alerts', function(alerts) {
                if (alerts.length > 0 && alerts[0].type === wfAlertTypes.success) {
                    $timeout(function() {
                        scope.alerts.shift();
                    }, 2000);
                }
            });
        }
    };
});
angular.module('wellFollowed').directive('wfApp', function($wfAuth, wfAlertTypes) {
   return {
       restrict: 'E',
       templateUrl: 'common/wf-app.html',
       controller: function($scope, $location) {

           $scope.alerts = [];
           $scope.showErrors = true;
           $scope.authentication = $wfAuth.authentication;
           $scope.previousState = {};

           this.getAuthentication = function() {
               return $scope.authentication;
           };

           this.showErrors = function(show) {
               $scope.showErrors = show;
           };

           this.addSuccess = function(message) {
                $scope.alerts.unshift({
                    type: wfAlertTypes.success,
                    message: message
                });
           };

           this.getPreviousState = function() {
                return $scope.previousState;
           };

           $scope.$on('$stateChangeSuccess', function(event, to, toParams, previous, previousParams) {
               $scope.showErrors = true;
               $scope.previousState = previous;
           });

           $scope.logOut = function() {
               $wfAuth.logout();
               $location.path('/connexion');
           }

       }
   }
});
angular.module('wellFollowed').directive('wfDeleteModal', function() {
    return {
        restrict: 'E',
        templateUrl: 'common/wf-delete-modal.html',
        scope: {
            close: '=',
            cancel: '&'
        },
        link: function(scope, element, attributes) {

        }
    };
});
angular.module('wellFollowed').directive('wfErrorAlert', function() {
   return {
       restrict: 'E',
       templateUrl: 'common/wf-error-alert.html',
       scope: {
           alert: '=alertObject',
           close: '=',
           alertCount: '='
       },
       link: function(scope, element, attributes) {

       }
   };
});
angular.module('wellFollowed').directive('wfErrorAlerts', function() {
   return {
       restrict: 'E',
       templateUrl: 'common/wf-error-alerts.html',
       link: function(scope, element, attributes) {
           scope.alerts = [];

           scope.$on('wfError', function(message) {
                scope.alerts.push({
                   message: message
                });
           });

           scope.close = function(alert) {
               scope.alerts.splice(scope.alerts.indexOf(alert), 1);
           };
       }
   };
});
angular.module('wellFollowed').directive('wfFormatDate', function() {
    return {
        restrict: 'A',
        require: '^ngModel',
        link: function(scope, element, attributes, ngModel) {

            ngModel.$formatters.push(function(value) {
                if (angular.isObject(value) && !!value.toDate) {
                    return value.toDate();
                }
                return new Date(value);
            });

            ngModel.$parsers.push(function(value) {
                return moment(value);
            });

        }
    };
});
angular.module('wellFollowed').directive('wfLoader', function() {
    return {
        restrict: 'AE',
        templateUrl: 'common/wf-loader.html',
        link: function (scope, element, attributes) {
            var parentHeight = element.parent().height();

            scope.marginTopBot = ((parentHeight - 32) / 2);
            if (scope.marginTopBot < 10) {
                scope.marginTopBot = 10;
            }
        }
    }
});
angular.module('wellFollowed').directive('wfMenu', function($wfMenu) {

    var _menuItems = function(scope) {
        if (scope.authentication.isAuth)
            scope.menuItems = $wfMenu.getMenu('main');
        else
            scope.menuItems = $wfMenu.getMenu('noauth');
    };

    return {
        restrict: 'E',
        templateUrl: 'common/wf-menu.html',
        link: function(scope, element, attributes, wfApp) {

            _menuItems(scope);

            scope.$on('$stateChangeSuccess', function(angularEvent, current, previous) {
                _menuItems(scope);
            });
        }
    };
});
angular.module('wellFollowed').directive('wfSuccessAlert', function() {
    return {
        restrict: 'E',
        templateUrl: 'common/wf-success-alert.html',
        scope: {
            alert: '=alertObject',
            close: '=',
            alertCount: '='
        },
        link: function(scope, element, attributes) {

        }
    };
});
angular.module('wellFollowed').directive('wfAdminInstitutionType', function($wfInstitutionType, $state) {
    return {
        restrict: 'E',
        templateUrl: 'admin/wf-admin-institution-type.html',
        scope: {
            institutionTypeId: '@'
        },
        require: '^wfApp',
        link: function(scope, element, attributes, wfApp) {

            scope.institutionType = null;

            if (!!scope.institutionTypeId) {
                $wfInstitutionType.getInstitutionType(scope.institutionTypeId)
                    .then(function (response) {
                        scope.institutionType = response.data;
                    });
            } else {
                scope.institutionType = {};
            }

            scope.createInstitutionType = function() {
                $wfInstitutionType.createInstitutionType(scope.institutionType)
                    .then(function() {
                        wfApp.addSuccess("Type d'établissement \"" + scope.institutionType.tag + "\" créé.");
                        $state.go('admin.institutionTypes');
                    });
            };

            scope.updateInstitutionType = function() {
                $wfInstitutionType.updateInstitutionType(scope.institutionType)
                    .then(function() {
                        wfApp.addSuccess("Type d'établissement mis à jour.");
                        $state.go('admin.institutionTypes');
                    });
            };

            scope.previousState = wfApp.getPreviousState().name || 'admin.institutionTypes';
        }
    };
});
angular.module('wellFollowed').directive('wfAdminInstitutionTypes', function ($wfInstitutionType, $wfModal) {
    return {
        restrict: 'E',
        templateUrl: 'admin/wf-admin-institution-types.html',
        require: '^wfApp',
        link: function (scope, element, attributes, wfApp) {

            scope.institutionTypes = null;

            var refresh = function () {
                $wfInstitutionType.getInstitutionTypes()
                    .then(function (response) {
                        scope.institutionTypes = response.data;
                    });
            };
            refresh();

            scope.deleteInstitutionType = function (id) {
                $wfModal.open({
                    scope: scope,
                    directiveName: 'wf-delete-modal'
                })
                    .then(function () {
                        scope.institutionTypes = null;
                        return $wfInstitutionType.deleteInstitutionType(id);
                    })
                    .then(function (response) {
                        wfApp.addSuccess("Type d'établissement supprimé.");
                    })
                    .finally(function () {
                        refresh();
                    });
            };
        }
    }
});
angular.module('wellFollowed').directive('wfAdminInstitution', function($wfInstitutionType, $wfInstitution, $state) {
    return {
        restrict: 'E',
        templateUrl: 'admin/wf-admin-institution.html',
        scope: {
            institutionId: '@'
        },
        require: '^wfApp',
        link: function(scope, element, attributes, wfApp) {

            scope.institution = null;
            scope.institutionTypes = [];

            $wfInstitutionType.getInstitutionTypes()
                .then(function(response) {
                    scope.institutionTypes = response.data;
                });


            if (!!scope.institutionId) {
                $wfInstitution.getInstitution(scope.institutionId)
                    .then(function (response) {
                        scope.institution = response.data;
                    });
            } else {
                scope.institution = {};
            }

            scope.createInstitution = function() {
                $wfInstitution.createInstitution(scope.institution)
                    .then(function() {
                        wfApp.addSuccess("Établissement \"" + scope.institution.tag + "\" créé.");
                        $state.go('admin.institutions');
                    });
            };

            scope.updateInstitution = function() {
                $wfInstitution.updateInstitution(scope.institution)
                    .then(function() {
                        wfApp.addSuccess("Établissement mis à jour.");
                        $state.go('admin.institutions');
                    });
            };

            scope.previousState = wfApp.getPreviousState().name || 'admin.institutions';
        }
    };
});
angular.module('wellFollowed').directive('wfAdminInstitutions', function($wfInstitution, $wfModal) {
    return {
        restrict: 'E',
        templateUrl: 'admin/wf-admin-institutions.html',
        require: '^wfApp',
        link: function(scope, element, attributes, wfApp) {

            scope.institutions = null;

            var refresh = function() {
                $wfInstitution.getInstitutions()
                    .then(function (response) {
                        scope.institutions = response.data;
                    });
            };
            refresh();

            scope.deleteInstitution = function(id) {
                $wfModal.open({
                    scope: scope,
                    directiveName: 'wf-delete-modal'
                })
                    .then(function () {
                        scope.institutions = null;
                        return $wfInstitution.deleteInstitution(id);
                    })
                    .then(function(response) {
                        wfApp.addSuccess("Établissement supprimé.");
                    })
                    .finally(function() {
                        refresh();
                    });
            };
        }
    }
});
angular.module('wellFollowed').directive('wfAdminUsers', function ($wfUser, $wfModal) {
    return {
        restrict: 'E',
        templateUrl: 'admin/wf-admin-users.html',
        require: '^wfApp',
        link: function (scope, element, attributes, wfApp) {

            scope.users = null;

            var refresh = function () {
                $wfUser.getUsers()
                    .then(function (response) {
                        scope.users = response.data;
                    });
            };
            refresh();

            scope.deleteUser = function (id) {
                $wfModal.open({
                    scope: scope,
                    directiveName: 'wf-delete-modal'
                })
                    .then(function () {
                        scope.users = null;
                        return $wfUser.deleteUser(id);
                    })
                    .then(function (response) {
                        wfApp.addSuccess("Utilisateur supprimé.");
                    })
                    .finally(function () {
                        refresh();
                    });
            };
        }
    }
});
angular.module('wellFollowed').directive('wfAdmin', function() {
   return {
       restrict: 'E',
       templateUrl: 'admin/wf-admin.html'
   };
});
angular.module('wellFollowed').constant('wfAlertTypes', {
    error: 'error',
    success: 'success'
});
angular.module('wellFollowed').constant('wfAuthSettings', {
   apiUrl: 'http://localhost:8085',
   websocketUrl: 'ws://localhost:8080'
});
angular.module('wellFollowed').constant('wfCrudTypes', {
    create: 'create',
    update: 'update',
    delete: 'delete',
    read: 'read'
});
angular.module('wellFollowed').constant('wfErrorCodes', {
    'UNKNOWN_ERROR': "Erreur inconnue.",
    'USER_EXISTS': "L'utilisateur renseigné existe déjà."
});
angular.module('wellFollowed').constant('wfResponseFormats', {
    formatList: "list",
    formatFull: "full"
});
angular.module('wellFollowed').directive('wfDummyRtSimulation', function(wfAuthSettings, $interval) {
    return {
        restrict: 'E',
        scope: {
            sensorName: '@'
        },
        link: function (scope, element, attributes) {
            var websocket = WS.connect(wfAuthSettings.websocketUrl);
            var wsSession = null;

            websocket.on('socket/connect', function (session) {
                wsSession = session;
                console.log('Websocket connection success.');

                $interval(function() {
                    var val = Math.floor((Math.random() * 10) + 9);
                    var p  = document.createElement('p');
                    angular.element(p).text('[' + new Date() + '] Value ' + val + ' sent to ' + scope.sensorName);
                    element.prepend(p);
                    wsSession.publish('sensor/data/' + scope.sensorName, {date: new Date(), val: val});
                }, 1000);
            });

            websocket.on('socket/disconnect', function (error) {
                wsSession = null;
            });
        }
    };
});
angular.module('wellFollowed').filter('wfError', function(wfErrorCodes) {
   return function(input) {
      return wfErrorCodes[input] || wfErrorCodes['UNKNOWN_ERROR'];
   };
});
angular.module('wellFollowed').directive('wfPlanningCalendar', function($wfEvent, $wfModal, wfCrudTypes, wfResponseFormats, uiCalendarConfig) {
    return {
        restrict: 'E',
        templateUrl: 'planning/wf-planning-calendar.html',
        controller: function($scope) {

            $scope.events = [];

            $scope.eventsF = function (start, end, timezone, callback) {
                var filter = {
                    start: start.toDate(),
                    end: end.toDate(),
                    format: wfResponseFormats.formatFull
                };

                $wfEvent.getEvents(filter)
                    .success(function (result) {
                        angular.merge($scope.events, result);
                        uiCalendarConfig.calendars
                            .eventsCalendar
                            .fullCalendar('refresh');
                    });
            };

            var commonModalOptions = {
                scope: $scope,
                directiveName: 'wf-planning-event-modal'
            };

            $scope.uiConfig = {
                calendar: {
                    header: {
                        left: 'prev,next today',
                        center: 'title',
                        right: 'month,agendaWeek,agendaDay'
                    },
                    lang: 'fr',
                    dayClick: function(date, jsEvent, view) {
                        $wfModal.open(angular.extend(commonModalOptions, {
                                data: {
                                    event: {
                                        start: date,
                                        end: date.add(2, 'hour'),
                                        title: 'Réservation'
                                    },
                                    jsEvent: jsEvent,
                                    view: view,
                                    type: wfCrudTypes.create
                                }
                            }))
                            .then(function(event) {
                                $scope.events.push(event);
                            });
                    },
                    eventClick: function(event, jsEvent, view) {
                        $wfModal.open(angular.extend(commonModalOptions, {
                                data: {
                                    event: {
                                        id: event.id,
                                        start: event.start,
                                        end: event.start.add(2, 'hour'),
                                        title: event.title
                                    },
                                    jsEvent: jsEvent,
                                    view: view,
                                    type: wfCrudTypes.read,
                                    title: 'Réservation'
                                }
                            }))
                            .then(function(event) {
                                $scope.events.splice($scope.events.indexOf(event), 1);
                                uiCalendarConfig.calendars
                                    .eventsCalendar
                                    .fullCalendar('refresh');
                            });
                    }
                }
            };

            $scope.eventSources = [$scope.eventsF, $scope.events];
        }
    };
});
angular.module('wellFollowed').directive('wfPlanningEventForm', function() {
    return {
        restrict: 'E',
        templateUrl: 'planning/wf-planning-event-form.html',
        scope: {
            eventForm: '=form',
            event: '=',
            readOnly: '=?'
        },
        require: '^form',
        link: function(scope, element, attributes, form) {

            scope.readOnly = scope.readOnly || false;

        }
    };
});
angular.module('wellFollowed').directive('wfPlanningEventModal', function($wfEvent) {
    return {
        restrict: 'E',
        templateUrl: 'planning/wf-planning-event-modal.html',
        scope: {
            close: '=',
            cancel: '&',
            data: '=?'
        },
        link: function(scope, element, attributes) {

            scope.event = scope.data.event || {};

            scope.createEvent = function() {
                $wfEvent.createEvent(scope.event).then(function(result) {
                    scope.close(result.data);
                });
            };

            scope.deleteEvent = function() {
                $wfEvent.deleteEvent(scope.event.id).then(function() {
                    scope.close(scope.event);
                });
            };
        }
    };
});
angular.module('wellFollowed').directive('wfPlanningSidebar', function() {
   return {
       restrict: 'E',
       templateUrl: 'planning/wf-planning-sidebar.html'
   };
});
angular.module('wellFollowed').directive('wfPlanning', function() {
    return {
        restrict: 'E',
        templateUrl: 'planning/wf-planning.html'
    };
});
angular.module('wellFollowed').directive('wfSensorTemperatureGraph', function() {
   return {
       restrict: 'E',
       templateUrl: 'sensor/wf-sensor-temperature-graph.html',
       require: '^wfSensor',
       link: function(scope, element, attributes, wfSensor) {

           var n = 243,
               duration = 750,
               now = new Date(Date.now() - duration),
               data = d3.range(n).map(function() { return 0; });

           var margin = {top: 6, right: 0, bottom: 20, left: 40},
               width = element.width() - margin.right,
               height = 120 - margin.top - margin.bottom;

           var x = d3.time.scale()
               .domain([now - (n - 2) * duration, now - duration])
               .range([0, width]);

           var y = d3.scale.linear()
               .range([height, 0]);

           var line = d3.svg.line()
               .interpolate("basis")
               .x(function(d, i) { return x(now - (n - 1 - i) * duration); })
               .y(function(d, i) { return y(d); });

           var svg = d3.select(element[0]).append("p").append("svg")
               .attr("width", width + margin.left + margin.right)
               .attr("height", height + margin.top + margin.bottom)
               .style("margin-left", -margin.left + "px")
               .append("g")
               .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

           svg.append("defs").append("clipPath")
               .attr("id", "clip")
               .append("rect")
               .attr("width", width)
               .attr("height", height);

           var axis = svg.append("g")
               .attr("class", "x axis")
               .attr("transform", "translate(0," + height + ")")
               .call(x.axis = d3.svg.axis().scale(x).orient("bottom"));

           var path = svg.append("g")
               .attr("clip-path", "url(#clip)")
               .append("path")
               .datum(data)
               .attr("class", "line");

           var transition = d3.select({}).transition()
               .duration(750)
               .ease("linear");

           d3.select(window)
               .on("resize", function() {

               });
           //d3.select(window)
           //    .on("scroll", function() { ++count; });

           var session = wfSensor.getWsSession();

           session.subscribe('sensor/data/' + scope.sensor.name, function(uri, payload) {

               scope.$apply(function() {
                   scope.currentTemp = payload.msg.val;
               });
               //data.push(payload.msg.val);
               //path.transition()
               //    .attr("transform", "translate(" + x(now - (n - 1) * duration) + ")");
               // update the domains
               now = new Date(payload.msg.date);
               x.domain([now - (n - 2) * duration, now - duration]);
               y.domain([0, d3.max(data)]);

               // push the accumulated count onto the back, and reset the count
               data.push(payload.msg.val);
               //count = 0;

               // redraw the line
               svg.select(".line")
                   .attr("d", line)
                   .attr("transform", null);

               // slide the x-axis left
               axis.call(x.axis);

               // slide the line left
               path.transition()
                   .attr("transform", "translate(" + x(now - (n - 1) * duration) + ")");

               // pop the old data point off the front
               data.shift();
           });

           //(function tick() {
           //    transition = transition.each(function() {
           //
           //        // update the domains
           //        now = new Date();
           //        x.domain([now - (n - 2) * duration, now - duration]);
           //        y.domain([0, d3.max(data)]);
           //
           //        // push the accumulated count onto the back, and reset the count
           //        //data.push(Math.min(30, count));
           //        //count = 0;
           //
           //        // redraw the line
           //        svg.select(".line")
           //            .attr("d", line)
           //            .attr("transform", null);
           //
           //        // slide the x-axis left
           //        axis.call(x.axis);
           //
           //        // slide the line left
           //        //path.transition()
           //        //    .attr("transform", "translate(" + x(now - (n - 1) * duration) + ")");
           //
           //        // pop the old data point off the front
           //        data.shift();
           //
           //    }).transition().each("start", tick);
           //})();


           //var n = 40,
           //    random = d3.random.normal(0, .2);
           //
           //function chart(domain, interpolation, tick) {
           //    var data = d3.range(n).map(random);
           //
           //    var margin = {top: 6, right: 0, bottom: 6, left: 40},
           //        width = element.width() - margin.right,
           //        height = 120 - margin.top - margin.bottom;
           //
           //    var x = d3.scale.linear()
           //        .domain(domain)
           //        .range([0, width]);
           //
           //    var y = d3.scale.linear()
           //        .domain([-1, 1])
           //        .range([height, 0]);
           //
           //    var line = d3.svg.line()
           //        .interpolate(interpolation)
           //        .x(function(d, i) { return x(i); })
           //        .y(function(d, i) { return y(d); });
           //
           //    var svg = d3.select(element[0]).append("p").append("svg")
           //        .attr("width", width + margin.left + margin.right)
           //        .attr("height", height + margin.top + margin.bottom)
           //        .style("margin-left", -margin.left + "px")
           //        .append("g")
           //        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
           //
           //    svg.append("defs").append("clipPath")
           //        .attr("id", "clip")
           //        .append("rect")
           //        .attr("width", width)
           //        .attr("height", height);
           //
           //    svg.append("g")
           //        .attr("class", "y axis")
           //        .call(d3.svg.axis().scale(y).ticks(5).orient("left"));
           //
           //    var path = svg.append("g")
           //        .attr("clip-path", "url(#clip)")
           //        .append("path")
           //        .datum(data)
           //        .attr("class", "line")
           //        .attr("d", line);
           //
           //    tick(path, line, data, x);
           //}
           //
           //var transition = d3.select({}).transition()
           //    .duration(750)
           //    .ease("linear");
           //
           //chart([1, n - 2], "basis", function tick(path, line, data, x) {
           //    transition = transition.each(function() {
           //
           //        // push a new data point onto the back
           //        data.push(random());
           //
           //        // redraw the line, and then slide it to the left, and repeat indefinitely
           //        path
           //            .attr("d", line)
           //            .attr("transform", null)
           //            .transition()
           //            .attr("transform", "translate(" + x(0) + ")");
           //
           //        // pop the old data point off the front
           //        data.shift();
           //
           //    }).transition().each("start", function() { tick(path, line, data, x); });
           //});

           //var w = element.width();
           //
           //var margin = {top: 20, right: 20, bottom: 30, left: 50},
           //    width = element.width() - margin.left - margin.right,
           //    height = 300 - margin.top - margin.bottom;
           //
           //var parseDate = d3.time.format("%d-%b-%y").parse;
           //
           //var x = d3.time.scale()
           //    .range([0, width]);
           //
           //var y = d3.scale.linear()
           //    .range([height, 0]);
           //
           //var xAxis = d3.svg.axis()
           //    .scale(x)
           //    .orient("bottom");
           //
           //var yAxis = d3.svg.axis()
           //    .scale(y)
           //    .orient("left");
           //
           //var line = d3.svg.line()
           //    .x(function(d) { return x(d.date); })
           //    .y(function(d) { return y(d.val); });
           //
           //var svg = d3.select(element[0]).append("svg")
           //    .attr("width", width + margin.left + margin.right)
           //    .attr("height", height + margin.top + margin.bottom)
           //    .append("g")
           //    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
           //
           ////d3.tsv("bundles/wellfollowed/data.tsv", function(error, data) {
           //scope.$watch('data', function(data) {
           //    //if (error) throw error;
           //
           //    if (!!data) {
           //        data.forEach(function (d) {
           //            d.date = parseDate(d.date);
           //            d.val = +d.val;
           //        });
           //
           //        x.domain(d3.extent(data, function (d) {
           //            return d.date;
           //        }));
           //        y.domain(d3.extent(data, function (d) {
           //            return d.val;
           //        }));
           //
           //        svg.append("g")
           //            .attr("class", "x axis")
           //            .attr("transform", "translate(0," + height + ")")
           //            .call(xAxis);
           //
           //        svg.append("g")
           //            .attr("class", "y axis")
           //            .call(yAxis)
           //            .append("text")
           //            .attr("transform", "rotate(-90)")
           //            .attr("y", 6)
           //            .attr("dy", ".71em")
           //            .style("text-anchor", "end")
           //            .text("Température");
           //
           //        svg.append("path")
           //            .datum(data)
           //            .attr("class", "line")
           //            .attr("d", line);
           //    }
           //
           //}, true);

       }
   };
});
angular.module('wellFollowed').directive('wfSensorTemperature', function() {
    return {
        restrict: 'E',
        templateUrl: 'sensor/wf-sensor-temperature.html',
        scope: {
            sensor: '='
        },
        require: '^wfSensor',
        controller: function($scope) {
            $scope.data = [];
        },
        link: function(scope, element, attributes, wfSensor) {
            scope.currentTemp = 0;
        }
    };
});
angular.module('wellFollowed').directive('wfSensor', function (wfAuthSettings, $wfSensor) {
    return {
        restrict: 'E',
        templateUrl: 'sensor/wf-sensor.html',
        controller: function ($scope) {
            $scope.hasWsSession = false;
            var websocket = WS.connect(wfAuthSettings.websocketUrl);
            var wsSession = null;

            websocket.on('socket/connect', function (session) {
                $scope.hasWsSession = true;
                wsSession = session;
                console.log('Websocket connection success.');
            });

            websocket.on('socket/disconnect', function (error) {
                $scope.hasWsSession = false;
                wsSession = null;
            });

            this.getWsSession = function () {
                return wsSession;
            };
        },
        link: function (scope, element, attributes) {
            scope.sensors = [];
            $wfSensor.getSensors().success(function(result) {
                scope.sensors = result;
            });
        }
    };
});
/**
 * Code adapté de l'article "AngularJS Token Authentication using ASP.NET Web API 2, Owin, and Identity" de Taiseer Joudeh sur CodeProject.com.
 * @author Taiseer Joudeh
 * @url http://www.codeproject.com/Articles/784106/AngularJS-Token-Authentication-using-ASP-NET-Web-A
 */
angular.module('wellFollowed').factory('$wfAuthInterceptor', function ($q, $location, localStorageService) {

    var _request = function (config) {

        config.headers = config.headers || {};

        var authData = localStorageService.get('authorizationData');
        if (authData) {
            config.headers.Authorization = 'Bearer ' + authData.token;
        }

        return config;
    };

    var _responseError = function (rejection) {
        if (rejection.status === 401 || rejection.status === 403) {
            $location.path('/connexion');
        }
        return $q.reject(rejection);
    };

    return {
        request: _request,
        responseError: _responseError
    };

});
/**
 * Code adapté de l'article "AngularJS Token Authentication using ASP.NET Web API 2, Owin, and Identity" de Taiseer Joudeh sur CodeProject.com.
 * @author Taiseer Joudeh
 * @url http://www.codeproject.com/Articles/784106/AngularJS-Token-Authentication-using-ASP-NET-Web-A
 */
angular.module('wellFollowed').factory('$wfAuth', function($http, $q, localStorageService, wfAuthSettings) {
    var serviceBase = wfAuthSettings.apiUrl + '/';
    var _baseUrl = wfAuthSettings.apiUrl + '/api/user';
    var authServiceFactory = {};

    var _authentication = {
        isAuth: false,
        userName : ""
    };

    var _createUser = function (registration) {

        _logout();

        return $http.post(_baseUrl, registration).then(function (response) {
            return response;
        });
    };

    var _login = function (loginData) {

        var data = "grant_type=password&username=" +
            loginData.username + "&password=" + loginData.password + "&client_id=user&scope=readsensor";
        debugger;
        var deferred = $q.defer();

        $http.post(serviceBase + 'token', data, { headers:
        { 'Content-Type': 'application/x-www-form-urlencoded' } }).success(function (response) {

            localStorageService.set('authorizationData',
                { token: response.access_token, username: loginData.username });

            _authentication.isAuth = true;
            _authentication.username = loginData.username;

            deferred.resolve(response);

        }).error(function (err, status) {
            _logout();
            deferred.reject(err);
        });

        return deferred.promise;
    };

    var _logout = function () {

        localStorageService.remove('authorizationData');

        _authentication.isAuth = false;
        _authentication.username = "";
    };

    var _fillAuthData = function () {

        var authData = localStorageService.get('authorizationData');
        if (authData)
        {
            _authentication.isAuth = true;
            _authentication.userName = authData.username;
        }
    };

    return {
        createUser: _createUser,
        login: _login,
        logout: _logout,
        fillAuthData: _fillAuthData,
        authentication: _authentication
    };
});
angular.module('wellFollowed').factory('$wfEvent', function($http, wfAuthSettings) {

    var _baseUrl = wfAuthSettings.apiUrl + '/api/event';

    var _createEvent = function(event) {
        return $http.post(_baseUrl, event);
    };

    var _getEvents = function(filter) {
        return $http.get(_baseUrl, { params: filter });
    };

    var _deleteEvent = function(id) {
        return $http.delete(_baseUrl + '/' + id);
    };

    return {
        getEvents: _getEvents,
        createEvent: _createEvent,
        deleteEvent: _deleteEvent
    };

});
angular.module('wellFollowed').factory('$wfInstitutionType', function($http, wfAuthSettings) {

    var _baseUrl = wfAuthSettings.apiUrl + '/api/institution-type';

    var _createInstitutionType = function(model) {
        return $http.post(_baseUrl, model);
    };

    var _getInstitutionTypes = function(filter) {
        return $http.get(_baseUrl, { params: filter });
    };

    var _getInstitutionType = function(id) {
        return $http.get(_baseUrl + '/' + id);
    };

    var _updateInstitutionType = function(model) {
        return $http.put(_baseUrl, model);
    };

    var _deleteInstitutionType = function(id) {
        return $http.delete(_baseUrl + '/' + id);
    };

    return {
        createInstitutionType: _createInstitutionType,
        getInstitutionTypes: _getInstitutionTypes,
        getInstitutionType: _getInstitutionType,
        updateInstitutionType: _updateInstitutionType,
        deleteInstitutionType: _deleteInstitutionType
    };

});
angular.module('wellFollowed').factory('$wfInstitution', function($http, wfAuthSettings) {

    var _baseUrl = wfAuthSettings.apiUrl + '/api/institution';

    var _createInstitution = function(model) {
        return $http.post(_baseUrl, model);
    };

    var _getInstitutions = function(filter) {
        return $http.get(_baseUrl, { params: filter });
    };

    var _getInstitution = function(id) {
        return $http.get(_baseUrl + '/' + id);
    };

    var _updateInstitution = function(model) {
        return $http.put(_baseUrl, model);
    };

    var _deleteInstitution = function(id) {
        return $http.delete(_baseUrl + '/' + id);
    };

    return {
        createInstitution: _createInstitution,
        getInstitutions: _getInstitutions,
        getInstitution: _getInstitution,
        updateInstitution: _updateInstitution,
        deleteInstitution: _deleteInstitution
    };

});
angular.module('wellFollowed').factory('$wfMenu', function() {
    var _menus = {
        'main': [
            { name: 'Sensor', state: 'sensor', right: 'ReadSensor' },
            { name: 'Calendrier', state: 'calendar', right: 'ReadCalendar' },
            { name: 'Compte', state: 'account', right: 'ReadAccount' },
            { name: 'Administration', right: 'ReadAdmin', items:
                [
                    { name: "Établissements", state: 'admin.institutions', right: 'ReadInstitutions' },
                    { name: "Types d'établissement", state: 'admin.institutionTypes', right: 'ReadInstitutionTypes'}
                ]
            }
        ],
        'noauth': [
            { name: 'S\'inscrire', state: 'subscription'},
            { name: 'Se connecter', state: 'login'}
        ]
    };

    var _getMenu = function(id, auth) {
        return _menus[id] || [];
    };

    return {
        getMenu: _getMenu
    };
});
angular.module('wellFollowed').factory('$wfModal', function($uibModal) {

    var _open = function(options) {

        options = angular.extend({
            data: {}
        }, options);

        var scope = options.scope.$new();

        var instance = $uibModal.open({
            scope: scope,
            controller: function($scope, $uibModalInstance) {

                $scope.data = options.data;

                $scope.cancel = function() {
                    $uibModalInstance.dismiss('cancel');
                };

                $scope.close = function(value) {
                    $uibModalInstance.close(value);
                };

            },
            template: '<' + options.directiveName + ' close="close" cancel="cancel()" data="data"></' + options.directiveName + '>',
            size: 'modal-lg'
        });

        return instance.result;
    };

    return {
        open: _open
    };

});
angular.module('wellFollowed').factory('$wfRight', function() {

    return {

    };
});
angular.module('wellFollowed').factory('$wfSensor', function($http, wfAuthSettings) {

    var _baseUrl = wfAuthSettings.apiUrl + '/api/sensor';

    var _getSensors = function(filter) {
        return $http.get(_baseUrl, {params: filter});
    };

    var _getSensor = function(name) {
        return $http.get(_baseUrl + '/' + name);
    };

    return {
        getSensors: _getSensors,
        getSensor: _getSensor
    };
});